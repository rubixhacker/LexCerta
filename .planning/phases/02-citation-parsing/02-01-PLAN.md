---
phase: 02-citation-parsing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/parser/types.ts
  - src/parser/reporters.ts
  - src/parser/index.ts
  - src/tools/parse-citation.ts
  - src/server.ts
  - src/__tests__/parser.test.ts
  - src/__tests__/parse-citation.test.ts
autonomous: true

must_haves:
  truths:
    - "parseCitation('123 S. Ct. 456') returns { ok: true, citation: { volume: 123, reporter: 'S. Ct.', page: 456 } }"
    - "parseCitation('123 S Ct 456') returns the same normalized result as '123 S. Ct. 456'"
    - "parseCitation('not a citation') returns { ok: false, error: { code: 'PARSE_ERROR', message: ... } }"
    - "All standard West Reporter abbreviations (U.S., S. Ct., L. Ed., L. Ed. 2d, F., F.2d, F.3d, F.4th, F. Supp., F. Supp. 2d, F. Supp. 3d, A., A.2d, A.3d, N.E., N.E.2d, N.E.3d, N.W., N.W.2d, P., P.2d, P.3d, S.E., S.E.2d, S.W., S.W.2d, S.W.3d, So., So. 2d, So. 3d) are recognized and normalized"
    - "parse_citation MCP tool is callable and returns structured response in ToolResponseEnvelope format"
  artifacts:
    - path: "src/parser/types.ts"
      provides: "ParsedCitation, CitationParseError, ParseResult types"
      contains: "ParseResult"
    - path: "src/parser/reporters.ts"
      provides: "Reporter lookup table and normalizeReporter function"
      exports: ["normalizeReporter"]
    - path: "src/parser/index.ts"
      provides: "Main parseCitation function"
      exports: ["parseCitation"]
    - path: "src/tools/parse-citation.ts"
      provides: "MCP tool registration for parse_citation"
      exports: ["registerParseCitationTool"]
    - path: "src/__tests__/parser.test.ts"
      provides: "Unit tests for parser module"
      contains: "parseCitation"
    - path: "src/__tests__/parse-citation.test.ts"
      provides: "Integration test for parse_citation MCP tool"
      contains: "parse_citation"
  key_links:
    - from: "src/tools/parse-citation.ts"
      to: "src/parser/index.ts"
      via: "import { parseCitation }"
      pattern: "parseCitation"
    - from: "src/tools/parse-citation.ts"
      to: "src/types.ts"
      via: "import { createToolResponse }"
      pattern: "createToolResponse"
    - from: "src/server.ts"
      to: "src/tools/parse-citation.ts"
      via: "import { registerParseCitationTool }"
      pattern: "registerParseCitationTool"
    - from: "src/parser/index.ts"
      to: "src/parser/reporters.ts"
      via: "import { normalizeReporter }"
      pattern: "normalizeReporter"
---

<objective>
Build a citation parser that accepts a legal citation string and returns a structured, normalized ParsedCitation object using TDD. The parser recognizes ~25 standard West Reporter abbreviations and normalizes variants (missing periods, spacing differences) to canonical Bluebook forms.

Purpose: This is the foundation for citation verification in Phase 3. Parsed citations feed into CourtListener API lookups. Without correct normalization, lookups will fail on variant input.
Output: Working `parseCitation()` function with full test coverage, registered as `parse_citation` MCP tool.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-citation-parsing/02-RESEARCH.md
@src/tools/echo.ts
@src/server.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for citation parser</name>
  <files>
    src/parser/types.ts
    src/__tests__/parser.test.ts
  </files>
  <action>
Create `src/parser/types.ts` with the type definitions needed by tests:

```typescript
export interface ParsedCitation {
  volume: number;
  reporter: string;       // Canonical Bluebook form
  page: number;
  raw: string;            // Original input
  normalized: string;     // Reconstructed "volume reporter page"
}

export interface CitationParseError {
  code: "PARSE_ERROR";
  message: string;
  input: string;
}

export type ParseResult =
  | { ok: true; citation: ParsedCitation }
  | { ok: false; error: CitationParseError };
```

Create `src/__tests__/parser.test.ts` with tests covering ALL four Phase 2 success criteria. Import `parseCitation` from `../parser/index.js` (does not exist yet -- tests MUST fail).

Test cases to include:

1. **Standard parsing** -- "123 S. Ct. 456" returns `{ ok: true, citation: { volume: 123, reporter: "S. Ct.", page: 456, raw: "123 S. Ct. 456", normalized: "123 S. Ct. 456" } }`

2. **Normalization equivalence** -- "123 S Ct 456" (no periods) returns identical result to "123 S. Ct. 456" (the `raw` field will differ but `volume`, `reporter`, `page`, `normalized` must match)

3. **Gibberish rejection** -- "not a citation" returns `{ ok: false, error: { code: "PARSE_ERROR", message: expect.stringContaining("Could not parse") } }`

4. **Empty input** -- "" returns error with message about empty input

5. **All standard West reporters via `it.each`** -- test each reporter with a sample citation:
   - "347 U.S. 483" -> "U.S."
   - "123 S. Ct. 456" -> "S. Ct."
   - "100 L. Ed. 200" -> "L. Ed."
   - "100 L. Ed. 2d 200" -> "L. Ed. 2d"
   - "500 F. 100" -> "F."
   - "500 F.2d 100" -> "F.2d"
   - "300 F.3d 200" -> "F.3d"
   - "50 F.4th 100" -> "F.4th"
   - "200 F. Supp. 100" -> "F. Supp."
   - "150 F. Supp. 2d 300" -> "F. Supp. 2d"
   - "150 F. Supp. 3d 300" -> "F. Supp. 3d"
   - "100 A. 200" -> "A."
   - "100 A.2d 200" -> "A.2d"
   - "100 A.3d 200" -> "A.3d"
   - "100 N.E. 200" -> "N.E."
   - "100 N.E.2d 200" -> "N.E.2d"
   - "100 N.E.3d 200" -> "N.E.3d"
   - "100 N.W. 200" -> "N.W."
   - "100 N.W.2d 200" -> "N.W.2d"
   - "100 P. 200" -> "P."
   - "100 P.2d 200" -> "P.2d"
   - "100 P.3d 200" -> "P.3d"
   - "100 S.E. 200" -> "S.E."
   - "100 S.E.2d 200" -> "S.E.2d"
   - "100 S.W. 200" -> "S.W."
   - "100 S.W.2d 200" -> "S.W.2d"
   - "100 S.W.3d 200" -> "S.W.3d"
   - "100 So. 200" -> "So."
   - "100 So. 2d 200" -> "So. 2d"
   - "100 So. 3d 200" -> "So. 3d"

6. **Variant normalization tests** -- verify period-stripping and spacing variants all normalize correctly:
   - "123 S Ct 456" -> "S. Ct."
   - "347 US 483" -> "U.S."
   - "500 F2d 100" -> "F.2d"
   - "123 s. ct. 456" (lowercase) -> "S. Ct."

7. **Unrecognized reporter** -- "123 Xyz. Rptr. 456" returns error (not silent failure)

8. **Pin cite tolerance** -- "347 U.S. 483, 490" parses successfully with page=483 (ignores trailing content)

9. **Parenthetical tolerance** -- "347 U.S. 483 (1954)" parses successfully with page=483

Run `npx vitest run src/__tests__/parser.test.ts` -- tests MUST FAIL (parseCitation does not exist yet). Commit the failing tests.
  </action>
  <verify>
`npx vitest run src/__tests__/parser.test.ts` exits with non-zero status. All tests fail with import error (module not found) or assertion errors. Zero tests pass.
  </verify>
  <done>Test file exists with 30+ test cases covering all 4 success criteria. Tests fail because implementation does not exist.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement citation parser to pass all tests</name>
  <files>
    src/parser/reporters.ts
    src/parser/index.ts
  </files>
  <action>
Create `src/parser/reporters.ts` with:

1. A `REPORTER_MAP: Record<string, string>` mapping normalized lookup keys (lowercase, periods stripped, whitespace collapsed) to canonical Bluebook forms. Cover all ~30 reporters from the test cases. Reference the complete table in 02-RESEARCH.md.

2. Export `normalizeReporter(raw: string): string | null` that:
   - Lowercases input
   - Strips all periods
   - Collapses whitespace to single spaces
   - Trims
   - Looks up in REPORTER_MAP
   - Returns canonical form or null if not found

Create `src/parser/index.ts` with:

1. Export `parseCitation(input: string): ParseResult` that:
   - Trims input, returns PARSE_ERROR for empty string
   - Matches against regex `^(\d+)\s+(.+?)\s+(\d+)` -- this captures volume, reporter text, and page. The regex anchors at start (`^`) and uses lazy match for reporter text so the LAST number group is the page.
   - **CRITICAL: Series suffix handling.** The lazy `.+?` will split "F. Supp. 2d" incorrectly because "2d" starts with a digit and the page capture `(\d+)` will grab "2". Fix: try the greedy reporter match first. Strategy: capture everything between first number and last number. Use `/^(\d+)\s+(.*\S)\s+(\d+)/` where the middle group is greedy and the last `(\d+)` is the final number in the string. The `$` is NOT anchored so trailing content (pin cites, parentheticals) is ignored.
   - More robust regex approach: `/^(\d+)\s+(.+?)\s+(\d+)(?:\s*[,(]|$)/` -- this ensures the page number is followed by end-of-string, comma, space, or paren. But simpler: just use the rightmost split. **Recommended approach:** Use a regex that captures from the right: find the LAST standalone number in the string as the page, then everything between the first number and that last number is the reporter text. Implementation:
     ```
     const match = input.match(/^(\d+)\s+(.+)\s+(\d+)/);
     ```
     The greedy `.+` captures as much as possible, but the final `\s+(\d+)` backtracks to capture the LAST number. This correctly handles "100 F. Supp. 2d 300" -> volume=100, reporter="F. Supp. 2d", page=300.
   - After regex match: `parseInt` volume and page, trim reporter text
   - Call `normalizeReporter(rawReporter)` -- if null, return PARSE_ERROR with message "Unrecognized reporter: {rawReporter}"
   - If normalized, return `{ ok: true, citation: { volume, reporter, page, raw: input, normalized: "${volume} ${reporter} ${page}" } }`
   - If no regex match, return PARSE_ERROR with descriptive message

Re-export types from `src/parser/types.ts` via the index for clean imports.

Run `npx vitest run src/__tests__/parser.test.ts` -- ALL tests MUST PASS. If any fail, fix the implementation (not the tests) until green. Commit the passing implementation.
  </action>
  <verify>
`npx vitest run src/__tests__/parser.test.ts` exits with status 0. All 30+ tests pass. Zero failures, zero skipped.
  </verify>
  <done>parseCitation function passes all tests including standard parsing, normalization, gibberish rejection, all West reporters, variant handling, pin cite tolerance, and parenthetical tolerance.</done>
</task>

<task type="auto">
  <name>Task 3: Wire parse_citation MCP tool and integration test</name>
  <files>
    src/tools/parse-citation.ts
    src/server.ts
    src/__tests__/parse-citation.test.ts
  </files>
  <action>
Create `src/tools/parse-citation.ts` following the exact pattern of `src/tools/echo.ts`:

```typescript
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { parseCitation } from "../parser/index.js";
import { createToolResponse } from "../types.js";

export function registerParseCitationTool(server: McpServer): void {
  server.registerTool(
    "parse_citation",
    {
      description: "Parse a legal citation string into a structured object with volume, reporter, and page. Normalizes common West Reporter format variants to canonical Bluebook forms.",
      inputSchema: {
        citation: z.string().min(1).describe("Legal citation string to parse, e.g., '347 U.S. 483'"),
      },
    },
    async ({ citation }) => {
      const result = parseCitation(citation);
      if (result.ok) {
        return createToolResponse({
          valid: true,
          metadata: {
            volume: result.citation.volume,
            reporter: result.citation.reporter,
            page: result.citation.page,
            normalized: result.citation.normalized,
          },
          error: null,
        });
      }
      return createToolResponse({
        valid: false,
        metadata: null,
        error: {
          code: result.error.code,
          message: result.error.message,
        },
      });
    },
  );
}
```

Modify `src/server.ts` to import and register the new tool:
- Add `import { registerParseCitationTool } from "./tools/parse-citation.js";`
- Call `registerParseCitationTool(server);` after `registerEchoTool(server);`
- Update logger line to include "parse_citation"

Create `src/__tests__/parse-citation.test.ts` -- an integration test that calls the `parse_citation` tool via the MCP server over Streamable HTTP (follow the same pattern as `src/__tests__/transport.test.ts`). Test:
1. Valid citation "347 U.S. 483" returns `{ valid: true, metadata: { volume: 347, reporter: "U.S.", page: 483, normalized: "347 U.S. 483" }, error: null }`
2. Invalid citation "not a citation" returns `{ valid: false, metadata: null, error: { code: "PARSE_ERROR", ... } }`
3. Zod validation rejects empty string input (Zod `.min(1)` enforces this)

Use the `mcpPost` test helper pattern from transport.test.ts to call the tool and parse the SSE response.

Run `npx vitest run` (all tests) -- everything MUST pass including the new integration tests AND all existing Phase 1 tests (no regressions). Commit the tool wiring.
  </action>
  <verify>
`npx vitest run` exits with status 0. All tests pass (parser unit tests + tool integration tests + existing Phase 1 tests). `npx vitest run src/__tests__/parse-citation.test.ts` specifically passes with 3+ tests.
  </verify>
  <done>parse_citation MCP tool is registered, callable over Streamable HTTP, returns ToolResponseEnvelope format for both success and error cases, and all existing tests still pass.</done>
</task>

</tasks>

<verification>
Run all checks after all tasks complete:

1. `npx vitest run` -- all tests pass (parser unit + tool integration + Phase 1 tests)
2. `npx tsc --noEmit` -- no TypeScript errors
3. `npx biome check src/` -- no lint errors
4. Manual spot check: start server (`COURTLISTENER_API_KEY=test npx tsx src/index.ts`), call parse_citation via curl:
   ```bash
   curl -X POST http://localhost:3000/mcp \
     -H "Content-Type: application/json" \
     -H "Accept: application/json, text/event-stream" \
     -d '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"parse_citation","arguments":{"citation":"347 U.S. 483"}}}'
   ```
   Response should contain `"valid":true` with volume=347, reporter="U.S.", page=483.
</verification>

<success_criteria>
- parseCitation("123 S. Ct. 456") returns structured object with volume=123, reporter="S. Ct.", page=456
- parseCitation("123 S Ct 456") normalizes to same result as "123 S. Ct. 456"
- parseCitation("not a citation") returns clear PARSE_ERROR
- All ~30 standard West Reporter abbreviations recognized and normalized
- parse_citation MCP tool callable over Streamable HTTP with ToolResponseEnvelope
- All Phase 1 tests still pass (no regressions)
- Zero TypeScript errors, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-citation-parsing/02-01-SUMMARY.md`
</output>
