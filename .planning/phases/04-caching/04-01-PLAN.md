---
phase: 04-caching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cache/citation-cache.ts
  - src/cache/__tests__/citation-cache.test.ts
  - src/tools/verify-citation.ts
  - src/tools/__tests__/verify-citation.test.ts
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "Verifying the same citation twice results in only one CourtListener API call"
    - "Cache lookups complete in under 50ms"
    - "Cached citation results never expire or are invalidated"
  artifacts:
    - path: "src/cache/citation-cache.ts"
      provides: "LRU cache wrapper with typed get/set/stats/clear"
      exports: ["CitationCache", "CachedLookup", "CacheStats"]
    - path: "src/cache/__tests__/citation-cache.test.ts"
      provides: "Unit tests for cache hit/miss, eviction, stats"
    - path: "src/tools/verify-citation.ts"
      provides: "Cache-integrated verify_west_citation handler"
    - path: "src/server.ts"
      provides: "Module-level singleton cache wired into tool registration"
  key_links:
    - from: "src/tools/verify-citation.ts"
      to: "src/cache/citation-cache.ts"
      via: "cache.get() before API call, cache.set() after ok response"
      pattern: "cache\\.get\\(|cache\\.set\\("
    - from: "src/server.ts"
      to: "src/cache/citation-cache.ts"
      via: "getCache() singleton passed to registerVerifyCitationTool"
      pattern: "getCache\\(\\)|sharedCache"
---

<objective>
Add an in-memory LRU cache to the citation verification pipeline so that repeated lookups for the same citation are served instantly from cache without consuming CourtListener API rate limit tokens.

Purpose: Citations are immutable legal records -- once verified, the result never changes. Caching eliminates redundant API calls, preserves rate limit budget, and makes repeated lookups near-instant.
Output: CitationCache class, cache integration in verify_west_citation handler, module-level singleton wiring, unit tests for cache behavior and integration.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-caching/04-RESEARCH.md
@src/server.ts
@src/tools/verify-citation.ts
@src/tools/__tests__/verify-citation.test.ts
@src/clients/courtlistener.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: CitationCache class with LRU backing and unit tests</name>
  <files>src/cache/citation-cache.ts, src/cache/__tests__/citation-cache.test.ts, package.json</files>
  <action>
Install lru-cache: `npm install lru-cache`

Create `src/cache/citation-cache.ts` with:
- `CachedLookup` interface: `{ matches: CitationMatch[] }` (import CitationMatch from `../clients/courtlistener.js`)
- `CacheStats` interface: `{ size, maxSize, hits, misses }` (all numbers)
- `CitationCache` class wrapping `LRUCache<string, CachedLookup>`:
  - Constructor takes optional `maxEntries` (default 1000), creates `new LRUCache({ max: maxEntries })` with NO ttl
  - `get(normalizedCitation: string): CachedLookup | undefined` -- increments hitCount on hit, missCount on miss (check `result !== undefined` not truthiness)
  - `set(normalizedCitation: string, result: CachedLookup): void`
  - `stats(): CacheStats` -- returns `{ size: cache.size, maxSize: cache.max, hits: hitCount, misses: missCount }`
  - `clear(): void` -- clears cache and resets both counters to 0

Create `src/cache/__tests__/citation-cache.test.ts` with tests:
1. `get() returns undefined for unknown key and increments misses`
2. `set() then get() returns cached value and increments hits`
3. `stats() reflects size, hits, misses correctly after operations`
4. `clear() resets cache and counters`
5. `LRU eviction: oldest entry evicted when max exceeded` -- create cache with max=2, add 3 entries, verify first is evicted
6. `get() performance: 1000 lookups complete in under 50ms` -- prime cache with an entry, run 1000 gets, assert total time < 50ms
  </action>
  <verify>
Run `npx vitest run src/cache/__tests__/citation-cache.test.ts` -- all tests pass.
Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>CitationCache class exists with typed get/set/stats/clear methods backed by lru-cache. All 6 unit tests pass. No TTL is configured (citations are immutable).</done>
</task>

<task type="auto">
  <name>Task 2: Wire cache into verify_west_citation tool and server singleton</name>
  <files>src/tools/verify-citation.ts, src/tools/__tests__/verify-citation.test.ts, src/server.ts</files>
  <action>
Modify `src/tools/verify-citation.ts`:
- Add import: `import type { CitationCache } from "../cache/citation-cache.js";`
- Change function signature to: `registerVerifyCitationTool(server: McpServer, client: CourtListenerClient, cache: CitationCache): void`
- After parse succeeds (Step 1) and before API call (Step 2), insert cache check:
  ```
  const normalized = parseResult.citation.normalized;
  const cached = cache.get(normalized);
  ```
- If `cached` is truthy, run the SAME match classification logic on `cached.matches` (extract the verifiedMatch / not_found block into a reusable path, or inline the cached response building). Return the same response shape as a fresh lookup would. Do NOT return a different format for cached vs fresh results.
- After a successful API response (`lookupResult.status === "ok"`), cache the result BEFORE classifying:
  ```
  cache.set(normalized, { matches: lookupResult.matches });
  ```
- Do NOT cache `rate_limited` or `error` responses (they are transient).

Modify `src/server.ts`:
- Add import: `import { CitationCache } from "./cache/citation-cache.js";`
- Add module-level singleton: `let sharedCache: CitationCache | null = null;`
- Add `getCache()` function (same pattern as `getClient()`): creates `new CitationCache()` on first call, returns singleton thereafter
- In `createServer()`: call `const cache = getCache();` and pass to `registerVerifyCitationTool(server, client, cache);`
- In `resetClient()`: add `sharedCache = null;` to also reset the cache singleton (rename function to `resetSingletons` if desired, but keep backward compat by also exporting `resetClient`)

Modify `src/tools/__tests__/verify-citation.test.ts`:
- Import `CitationCache` from `../../cache/citation-cache.js`
- Update `captureHandler()` to create `const cache = new CitationCache();` and pass it: `registerVerifyCitationTool(mockServer, mockClient, cache);`
- Return `cache` from `captureHandler()` so tests can inspect it
- All existing tests should continue to pass (cache is transparent on first call)
- Add new tests:
  1. `"serves second lookup from cache without API call"` -- call handler twice with same citation, assert `lookupCitation` called exactly once
  2. `"does not cache rate_limited responses"` -- mock rate_limited response, call twice, assert `lookupCitation` called twice
  3. `"does not cache error responses"` -- mock error response, call twice, assert `lookupCitation` called twice
  4. `"cache lookup completes in under 50ms"` -- prime cache with one call, time second call, assert < 50ms
  </action>
  <verify>
Run `npx vitest run src/tools/__tests__/verify-citation.test.ts` -- all tests pass (existing + 4 new).
Run `npx vitest run` -- full test suite passes (no regressions).
Run `npx tsc --noEmit` -- no type errors.
  </verify>
  <done>Cache is wired as module-level singleton in server.ts. verify_west_citation checks cache after parse, stores on ok, skips on rate_limited/error. All existing tests pass unchanged. Four new tests prove: cache deduplicates API calls, transient failures are not cached, cache lookups are sub-50ms.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- full test suite passes with zero failures
2. `npx tsc --noEmit` -- clean TypeScript compilation
3. Verify cache hit test: second call to same citation triggers zero additional API calls
4. Verify performance test: cached lookup < 50ms
5. Verify no TTL: grep `ttl` in citation-cache.ts returns no matches (no expiry configured)
</verification>

<success_criteria>
- Verifying "347 U.S. 483" twice results in exactly one `lookupCitation` call (proven by test)
- Cache lookup performance test passes (< 50ms, proven by test)
- No TTL or expiry is configured in the cache (citations are immutable)
- rate_limited and error responses are never cached (proven by tests)
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-caching/04-01-SUMMARY.md`
</output>
