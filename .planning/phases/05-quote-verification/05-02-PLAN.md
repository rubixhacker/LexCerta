---
phase: 05-quote-verification
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/tools/verify-quote.ts
  - src/tools/__tests__/verify-quote.test.ts
  - src/server.ts
autonomous: true

must_haves:
  truths:
    - "verify_quote_integrity MCP tool is callable over Streamable HTTP"
    - "Nonexistent citation returns citation-not-found error before attempting quote matching"
    - "Verbatim quote from a real opinion returns high match score (90+)"
    - "Fabricated quote returns low match score with actual text from opinion for comparison"
    - "Minor formatting differences do not cause false negatives"
  artifacts:
    - path: "src/tools/verify-quote.ts"
      provides: "verify_quote_integrity MCP tool registration"
      exports: ["registerVerifyQuoteTool"]
    - path: "src/server.ts"
      provides: "Tool registration wiring"
      contains: "registerVerifyQuoteTool"
  key_links:
    - from: "src/tools/verify-quote.ts"
      to: "src/tools/verify-citation.ts"
      via: "Reuses parseCitation + client.lookupCitation for citation-first verification"
      pattern: "parseCitation|lookupCitation"
    - from: "src/tools/verify-quote.ts"
      to: "src/clients/courtlistener.ts"
      via: "client.fetchClusterOpinions for opinion text retrieval"
      pattern: "fetchClusterOpinions"
    - from: "src/tools/verify-quote.ts"
      to: "src/matching/fuzzy-match.ts"
      via: "matchQuoteAcrossOpinions for fuzzy matching"
      pattern: "matchQuoteAcrossOpinions"
    - from: "src/tools/verify-quote.ts"
      to: "src/cache/opinion-cache.ts"
      via: "OpinionCache for caching opinion text"
      pattern: "opinionCache\\.get|opinionCache\\.set"
    - from: "src/server.ts"
      to: "src/tools/verify-quote.ts"
      via: "registerVerifyQuoteTool(server, client, citationCache, opinionCache)"
      pattern: "registerVerifyQuoteTool"
---

<objective>
Wire the verify_quote_integrity MCP tool that orchestrates citation verification, opinion text fetching, fuzzy matching, and returns a structured result with match score and excerpt.

Purpose: This is the user-facing tool that satisfies QUOTE-01 through QUOTE-05 -- the competitive differentiator for LexCerta.
Output: A registered MCP tool callable by AI agents, plus server.ts wiring and tests.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-quote-verification/05-RESEARCH.md
@.planning/phases/05-quote-verification/05-01-SUMMARY.md
@src/tools/verify-citation.ts
@src/server.ts
@src/types.ts
@src/clients/courtlistener.ts
@src/matching/fuzzy-match.ts
@src/cache/opinion-cache.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verify_quote_integrity MCP tool</name>
  <files>
    src/tools/verify-quote.ts
    src/tools/__tests__/verify-quote.test.ts
  </files>
  <action>
**Create `src/tools/verify-quote.ts`:**

Export `registerVerifyQuoteTool(server: McpServer, client: CourtListenerClient, citationCache: CitationCache, opinionCache: OpinionCache): void`.

Register tool `"verify_quote_integrity"` with:
- Description: "Verify that a quoted passage actually appears in a cited court opinion. Returns a match score (0-100), classification (high/medium/low), and the best-matching excerpt from the opinion for comparison. First confirms the citation exists before fetching opinion text."
- Input schema:
  - `citation`: z.string().min(1).describe("West Reporter citation, e.g., '347 U.S. 483'")
  - `text`: z.string().min(1).describe("Quoted passage to verify against the opinion text")

**Handler pipeline (5 steps):**

1. **Parse citation** -- call `parseCitation(citation)`. If `!parseResult.ok`, return `createToolResponse` with `PARSE_ERROR` (same pattern as verify-citation).

2. **Verify citation exists** -- check `citationCache.get(normalized)` first. If cache miss, call `client.lookupCitation(normalized)`. Handle `rate_limited` and `error` responses same as verify-citation. If no verified match (no match with status 200 + clusters), return `CITATION_NOT_FOUND` error with message "Cannot verify quote: citation not found in CourtListener database." This satisfies QUOTE-04 (citation check before text fetch).

3. **Fetch opinion text** -- extract cluster ID from the first verified cluster's `absolute_url` (parse the numeric ID from the URL path, e.g., `/opinion/12345/brown-v-board/` -> 12345). Check `opinionCache.get(clusterId)` first. If cache miss, call `client.fetchClusterOpinions(clusterId)`. Handle rate_limited, error, not_found responses. On success, cache in opinionCache. If no opinions have text, return `TEXT_UNAVAILABLE` error.

4. **Fuzzy match** -- call `matchQuoteAcrossOpinions(text, opinions)` from the matching module. This returns the best match score, classification, excerpt, and opinion metadata.

5. **Return result** -- use `createToolResponse` with:
```typescript
{
  valid: result.score >= 70,  // "valid" means the quote likely exists in the opinion
  metadata: {
    status: "quote_verified",
    matchScore: result.score,
    classification: result.classification,
    bestMatchExcerpt: result.bestMatchExcerpt,
    matchedOpinionType: result.matchedOpinionType,
    matchedOpinionId: result.matchedOpinionId,
    caseName: cluster.case_name,
    court: cluster.docket.court,
    ...(result.shortQuoteWarning ? { warning: "Quote is very short (<20 chars). Match score may be unreliable." } : {}),
  },
  error: result.score < 70 ? {
    code: "QUOTE_NOT_FOUND",
    message: `Quote does not appear to match the cited opinion (score: ${result.score}/100).`,
    details: { bestMatchExcerpt: result.bestMatchExcerpt },
  } : null,
}
```

Note: `valid: true` when score >= 70 is a reasonable default. The raw score is always returned so consumers can apply their own threshold.

**TDD tests in `src/tools/__tests__/verify-quote.test.ts`:**

Use the same mock server pattern as existing tool tests (mock `server.registerTool` to capture the handler, then call the handler directly with mock args).

Mock `CourtListenerClient` with mock `lookupCitation` and `fetchClusterOpinions`. Mock `CitationCache` and `OpinionCache`. Mock `matchQuoteAcrossOpinions` from the matching module (vi.mock).

Test cases:
1. Unparseable citation -> PARSE_ERROR response
2. Citation not found (lookupCitation returns ok but no verified matches) -> CITATION_NOT_FOUND
3. Rate limited on citation lookup -> RATE_LIMITED
4. Rate limited on opinion fetch -> RATE_LIMITED
5. Opinion text unavailable (fetchClusterOpinions returns ok but empty opinions) -> TEXT_UNAVAILABLE
6. High match (score 95) -> valid=true, status=quote_verified, matchScore=95
7. Low match (score 30) -> valid=false, QUOTE_NOT_FOUND error with excerpt
8. Citation cache hit (lookupCitation not called) -> uses cached citation data
9. Opinion cache hit (fetchClusterOpinions not called) -> uses cached opinion text
10. Short quote warning propagated in metadata
  </action>
  <verify>
```bash
cd /var/home/stewart/Workspace/LexCerta && npx vitest run src/tools/__tests__/verify-quote.test.ts
```
All 10 tests pass.
  </verify>
  <done>
verify_quote_integrity tool handler exists with 5-step pipeline: parse -> verify citation -> fetch text -> fuzzy match -> return result. All 10 test cases pass covering every response path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire tool into server and run full test suite</name>
  <files>
    src/server.ts
  </files>
  <action>
**Update `src/server.ts`:**

1. Import `OpinionCache` from `"./cache/opinion-cache.js"`.
2. Import `registerVerifyQuoteTool` from `"./tools/verify-quote.js"`.
3. Add `sharedOpinionCache` singleton (same pattern as `sharedCache`):
```typescript
let sharedOpinionCache: OpinionCache | null = null;

function getOpinionCache(): OpinionCache {
  if (!sharedOpinionCache) {
    sharedOpinionCache = new OpinionCache();
  }
  return sharedOpinionCache;
}
```
4. In `resetClient()`, add `sharedOpinionCache = null;`.
5. In `createServer()`, add:
```typescript
const opinionCache = getOpinionCache();
registerVerifyQuoteTool(server, client, cache, opinionCache);
```
6. Update the logger.debug line to include the new tool name:
```typescript
logger.debug("Registered tools: echo, parse_citation, verify_west_citation, verify_quote_integrity");
```

**Verification:** Run the full test suite to confirm no regressions:
```bash
npx vitest run
npx tsc --noEmit
npx biome check src/
```
  </action>
  <verify>
```bash
cd /var/home/stewart/Workspace/LexCerta && npx vitest run && npx tsc --noEmit && npx biome check src/
```
All tests pass, no type errors, no lint errors.
  </verify>
  <done>
verify_quote_integrity is registered in server.ts with singleton OpinionCache. All existing tests continue to pass alongside new tests. Full test suite green, TypeScript compiles, biome clean.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- full suite passes (all existing + ~10 new tool tests)
2. `npx tsc --noEmit` -- no type errors
3. `npx biome check src/` -- no lint issues
4. verify_quote_integrity appears in server.ts tool registration
5. Phase 5 success criteria:
   - SC1: High match score for verbatim quote (tested in verify-quote.test.ts case 6)
   - SC2: Low match score with excerpt for fabricated quote (tested in case 7)
   - SC3: Citation-not-found error before quote matching (tested in case 2)
   - SC4: Fuzzy matching handles formatting differences (tested via matchQuoteInOpinion in Plan 01)
</verification>

<success_criteria>
- verify_quote_integrity MCP tool registered and callable
- Citation existence checked before opinion text fetch (QUOTE-04)
- Match score 0-100 returned (QUOTE-02)
- Best-match excerpt returned for comparison (QUOTE-03)
- Tool uses fuzzy matching for formatting tolerance (QUOTE-05)
- Opinion text cached to avoid redundant API calls
- All tests pass, types check, lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/05-quote-verification/05-02-SUMMARY.md`
</output>
