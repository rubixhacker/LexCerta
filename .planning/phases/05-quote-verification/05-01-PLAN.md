---
phase: 05-quote-verification
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/clients/courtlistener.ts
  - src/clients/__tests__/courtlistener-opinions.test.ts
  - src/cache/opinion-cache.ts
  - src/cache/__tests__/opinion-cache.test.ts
  - src/matching/fuzzy-match.ts
  - src/matching/__tests__/fuzzy-match.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "fetchClusterOpinions returns plain text for all sub-opinions in a cluster"
    - "Opinion text cache stores and retrieves full text keyed by cluster ID"
    - "Fuzzy matching returns a 0-100 score and best-match excerpt for a quote against opinion text"
    - "Text normalization handles smart quotes, em-dashes, and collapsed whitespace"
  artifacts:
    - path: "src/clients/courtlistener.ts"
      provides: "fetchClusterOpinions method on CourtListenerClient"
      contains: "fetchClusterOpinions"
    - path: "src/cache/opinion-cache.ts"
      provides: "Separate LRU cache for opinion full text"
      exports: ["OpinionCache"]
    - path: "src/matching/fuzzy-match.ts"
      provides: "Pure fuzzy matching functions"
      exports: ["matchQuoteInOpinion", "normalizeText"]
    - path: "package.json"
      provides: "fuzzball dependency"
      contains: "fuzzball"
  key_links:
    - from: "src/clients/courtlistener.ts"
      to: "CourtListener /clusters/ and /opinions/ endpoints"
      via: "fetchClusterOpinions method using existing policy and rateLimiter"
      pattern: "this\\.policy\\.execute"
    - from: "src/matching/fuzzy-match.ts"
      to: "fuzzball"
      via: "partial_ratio for substring fuzzy matching"
      pattern: "fuzzball\\.partial_ratio"
---

<objective>
Add CourtListener opinion-text fetching, a separate opinion text cache, and a pure fuzzy matching module -- the three building blocks the verify_quote_integrity tool needs.

Purpose: These modules must exist before the MCP tool (Plan 02) can wire them together. Each is independently testable with clear I/O contracts, making them TDD candidates.
Output: Three tested modules (client method, cache, matcher) plus fuzzball dependency installed.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-quote-verification/05-RESEARCH.md
@src/clients/courtlistener.ts
@src/cache/citation-cache.ts
@src/resilience/circuit-breaker.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fuzzball and add fetchClusterOpinions to CourtListenerClient</name>
  <files>
    package.json
    src/clients/courtlistener.ts
    src/clients/__tests__/courtlistener-opinions.test.ts
  </files>
  <action>
**Install dependency:**
```bash
npm install fuzzball
```

**Add types and method to `src/clients/courtlistener.ts`:**

Add these types after the existing `LookupResponse` type:

```typescript
export interface OpinionText {
  opinionId: number;
  type: string;       // "010combined", "020lead", "030concurrence", "040dissent", etc.
  plainText: string;
  clusterId: number;
}

export type OpinionTextResponse =
  | { status: "ok"; opinions: OpinionText[] }
  | { status: "rate_limited"; retryAfterMs: number }
  | { status: "error"; code: string; message: string }
  | { status: "not_found" };
```

Add `fetchClusterOpinions(clusterId: number): Promise<OpinionTextResponse>` method to `CourtListenerClient`. The method:

1. Checks `this.rateLimiter.tryConsume()` before entering the circuit breaker (same pattern as `lookupCitation`).
2. Uses `this.policy.execute()` to GET `${this.baseUrl}/clusters/${clusterId}/` with Authorization header.
3. Handles 429 (throw RateLimitError), 404 (return `{ status: "not_found" }`), 5xx (throw ApiError).
4. Reads `cluster.sub_opinions` (array of absolute URLs like `"https://www.courtlistener.com/api/rest/v4/opinions/12345/"`).
5. For each sub_opinion URL, fetches the opinion. Does NOT consume additional rate limiter tokens for sub-opinion fetches -- only the initial cluster fetch counts (sub-opinions are part of the same logical request).
6. For each fetched opinion, extracts text via fallback chain: `op.plain_text` first, then strip HTML from `op.html` if plain_text is empty. Use a simple regex for HTML stripping: `text.replace(/<[^>]*>/g, "").replace(/&[^;]+;/g, " ").replace(/\s+/g, " ").trim()`. This is acceptable here because we only use it as a fallback and the text is for fuzzy matching, not rendering.
7. Collects all opinions with non-empty text into the `OpinionText[]` array.
8. Returns `{ status: "ok", opinions }`.
9. Catches RateLimitError -> `{ status: "rate_limited", retryAfterMs }`. Catches other errors -> `{ status: "error", code: "API_ERROR", message }`.

**TDD: Write tests in `src/clients/__tests__/courtlistener-opinions.test.ts`:**

Use the same mock pattern as the existing `courtlistener.test.ts` (mock policy, mock rateLimiter, mock fetch via vi.stubGlobal).

Test cases:
- Rate limiter denies -> returns rate_limited
- Cluster 404 -> returns not_found
- Cluster 200 with 2 sub_opinions (one lead, one dissent), both with plain_text -> returns ok with 2 OpinionText entries
- Cluster 200, sub_opinion has empty plain_text but has html -> falls back to stripped html
- Cluster 200, sub_opinion has no text at all -> skipped (not in results)
- Cluster 5xx -> returns error
- Cluster 429 -> returns rate_limited with retryAfterMs

RED first: write tests, confirm they fail, then implement, confirm they pass.
  </action>
  <verify>
```bash
cd /var/home/stewart/Workspace/LexCerta && npx vitest run src/clients/__tests__/courtlistener-opinions.test.ts
```
All 7 tests pass. Also confirm existing tests still pass:
```bash
npx vitest run
```
  </verify>
  <done>
fetchClusterOpinions method exists on CourtListenerClient, follows same resilience patterns as lookupCitation, returns discriminated union OpinionTextResponse, and all 7+ new tests pass alongside existing tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Opinion text cache and fuzzy matching module</name>
  <files>
    src/cache/opinion-cache.ts
    src/cache/__tests__/opinion-cache.test.ts
    src/matching/fuzzy-match.ts
    src/matching/__tests__/fuzzy-match.test.ts
  </files>
  <action>
**Create `src/cache/opinion-cache.ts`:**

Follow the same pattern as `citation-cache.ts` but keyed by cluster ID (number, converted to string key). Store `OpinionText[]` (the array of all sub-opinions for a cluster). Use a smaller max (200 entries) since opinion text is much larger (~100KB per entry vs ~1KB for citation metadata). Include get/set/stats/clear methods matching CitationCache API. No TTL (same rationale: opinion text is immutable).

```typescript
import { LRUCache } from "lru-cache";
import type { OpinionText } from "../clients/courtlistener.js";

export interface CachedOpinionText {
  opinions: OpinionText[];
}

export class OpinionCache {
  // Same shape as CitationCache: constructor(maxEntries), get, set, stats, clear
}
```

**TDD tests in `src/cache/__tests__/opinion-cache.test.ts`:**
- get returns undefined on miss, increments missCount
- set then get returns cached value, increments hitCount
- respects max entries (evicts oldest)
- clear resets size and counters
- stats returns correct shape

**Create `src/matching/fuzzy-match.ts`:**

Pure module, zero MCP SDK dependency. Exports:

1. `normalizeText(text: string): string` -- collapse whitespace, normalize smart quotes (\u2018-\u201B -> ', \u201C-\u201F -> "), normalize em/en dashes (\u2013\u2014 -> -), normalize non-breaking spaces (\u00A0 -> space), trim.

2. `matchQuoteInOpinion(quote: string, opinionText: string): MatchResult` where:
```typescript
export interface MatchResult {
  score: number;                              // 0-100
  classification: "high" | "medium" | "low";  // high: 90+, medium: 70-89, low: <70
  bestMatchExcerpt: string;                   // best-matching substring from opinion with ~50 chars context
}
```

Implementation:
- Normalize both strings with `normalizeText`.
- Validate minimum quote length (20 chars after normalization). If shorter, still match but include a warning flag: `shortQuoteWarning: true` in the result type.
- Use `fuzzball.partial_ratio(normalizedQuote, normalizedOpinion)` for the score.
- For excerpt extraction: use a sliding window of quote-length over the normalized opinion text. For each window position, compute `fuzzball.ratio(normalizedQuote, window)`. Track the highest-scoring window. Return that window plus ~50 chars of surrounding context. If opinion text is very long (>50K chars), chunk into paragraphs (split on `\n\n`) and match against each paragraph to avoid O(n*m) on huge texts.
- Classify: score >= 90 -> "high", score >= 70 -> "medium", else "low".

3. `matchQuoteAcrossOpinions(quote: string, opinions: OpinionText[]): BestMatchResult` where:
```typescript
export interface BestMatchResult extends MatchResult {
  matchedOpinionId: number;
  matchedOpinionType: string;
}
```
Runs `matchQuoteInOpinion` against each opinion's plainText and returns the best-scoring result with the opinion metadata.

**TDD tests in `src/matching/__tests__/fuzzy-match.test.ts`:**
- normalizeText collapses whitespace
- normalizeText converts smart quotes to straight quotes
- normalizeText converts em-dashes to hyphens
- matchQuoteInOpinion: verbatim quote returns score 95+ and classification "high"
- matchQuoteInOpinion: quote with extra spaces returns score 85+ (fuzzy handles it)
- matchQuoteInOpinion: fabricated quote returns score <50 and classification "low"
- matchQuoteInOpinion: bestMatchExcerpt contains relevant text from opinion
- matchQuoteInOpinion: short quote (<20 chars) sets shortQuoteWarning
- matchQuoteAcrossOpinions: returns best match across multiple opinions with correct opinionId

RED first: write all tests, confirm failure, then implement, confirm pass.
  </action>
  <verify>
```bash
cd /var/home/stewart/Workspace/LexCerta && npx vitest run src/cache/__tests__/opinion-cache.test.ts src/matching/__tests__/fuzzy-match.test.ts
```
All tests pass (expect ~14 total: 5 cache + 9 matching). Also confirm full suite:
```bash
npx vitest run
```
  </verify>
  <done>
OpinionCache class exists with get/set/stats/clear. matchQuoteInOpinion returns score + classification + excerpt. matchQuoteAcrossOpinions finds best match across multiple opinions. normalizeText handles smart quotes, dashes, whitespace. All new and existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (existing + ~21 new)
2. `npx tsc --noEmit` -- no type errors
3. `npx biome check src/` -- no lint errors
4. `fuzzball` appears in package.json dependencies
5. No changes to existing tool behavior (verify-citation tests still pass)
</verification>

<success_criteria>
- CourtListenerClient.fetchClusterOpinions fetches cluster then sub-opinions, returns OpinionText[]
- OpinionCache stores/retrieves opinion text arrays with LRU eviction
- matchQuoteInOpinion returns 0-100 score with excerpt extraction
- normalizeText handles smart quotes, dashes, whitespace normalization
- All modules are pure/testable with no MCP SDK dependency
- fuzzball installed as project dependency
</success_criteria>

<output>
After completion, create `.planning/phases/05-quote-verification/05-01-SUMMARY.md`
</output>
