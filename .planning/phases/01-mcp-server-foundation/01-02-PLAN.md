---
phase: 01-mcp-server-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/transport.ts
  - src/types.ts
  - src/__tests__/config.test.ts
  - src/__tests__/envelope.test.ts
  - src/__tests__/transport.test.ts
autonomous: true

must_haves:
  truths:
    - "MCP client can connect via SSE fallback (GET /sse) and receive a valid capabilities response"
    - "Tool call with invalid input returns a Zod validation error before any processing occurs"
    - "All tool responses use the same JSON envelope format with valid, metadata, and error fields"
    - "Server refuses to start if required environment variables are missing"
  artifacts:
    - path: "src/transport.ts"
      provides: "Express app with both Streamable HTTP and SSE fallback routes"
      contains: "SSEServerTransport"
    - path: "src/__tests__/config.test.ts"
      provides: "Tests for config validation behavior"
      contains: "COURTLISTENER_API_KEY"
    - path: "src/__tests__/envelope.test.ts"
      provides: "Tests for response envelope format"
      contains: "createToolResponse"
    - path: "src/__tests__/transport.test.ts"
      provides: "Integration tests for Streamable HTTP and SSE endpoints"
      contains: "POST /mcp"
  key_links:
    - from: "src/transport.ts"
      to: "@modelcontextprotocol/sdk/server/sse.js"
      via: "SSEServerTransport import for legacy fallback"
      pattern: "SSEServerTransport"
    - from: "src/transport.ts"
      to: "src/server.ts"
      via: "GET /sse handler creates server + SSE transport, POST /messages routes to active transport"
      pattern: "sseTransports"
    - from: "src/__tests__/transport.test.ts"
      to: "src/transport.ts"
      via: "Tests exercise POST /mcp, GET /sse, POST /messages endpoints"
      pattern: "createApp"
---

<objective>
Add SSE backward compatibility, validate Zod input rejection, and add integration tests proving all Phase 1 success criteria.

Purpose: Complete the MCP server with SSE fallback for older clients (MCP-02), verify that Zod validation rejects invalid inputs before handler execution (MCP-03), and write tests that prove every Phase 1 success criterion is met. Tests are the evidence that the phase is done.

Output: A fully tested MCP server with both Streamable HTTP and SSE transports, proven input validation, and consistent response envelopes.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mcp-server-foundation/01-RESEARCH.md
@.planning/phases/01-mcp-server-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSE fallback transport endpoints</name>
  <files>
    src/transport.ts
  </files>
  <action>
Add legacy SSE transport endpoints to the Express app in transport.ts (MCP-02). This enables backward compatibility with pre-March 2025 MCP clients.

Import `SSEServerTransport` from `@modelcontextprotocol/sdk/server/sse.js`.

Add a module-level `Map<string, SSEServerTransport>` to track active SSE sessions.

Add two new routes to the Express app returned by `createApp()`:

**GET /sse** -- SSE event stream endpoint:
- Create a new server via `createServer()`
- Create `new SSEServerTransport("/messages", res)` -- the first argument tells the client where to POST messages
- Store the transport in the Map keyed by `transport.sessionId`
- On response close: delete from Map, call `server.close()`
- Call `await server.connect(transport)` to start the SSE stream
- Log connection via logger

**POST /messages** -- SSE message endpoint:
- Read `sessionId` from `req.query.sessionId` (string)
- Look up transport in the Map
- If not found, return 400 with `{ error: "Unknown or expired session" }`
- If found, call `await transport.handlePostMessage(req, res, req.body)`
- Wrap in try/catch; on error, log and return 500

After adding routes:
1. Start server: `COURTLISTENER_API_KEY=test-key npx tsx src/index.ts &`
2. Test SSE connection with curl: `curl -N http://localhost:3000/sse` -- should receive SSE event stream with endpoint event containing /messages?sessionId=...
3. Extract the sessionId from the endpoint event, then POST an initialize request: `curl -X POST "http://localhost:3000/messages?sessionId=EXTRACTED_ID" -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}},"id":1}'`
4. Verify the SSE stream receives the capabilities response
5. Kill the background server
  </action>
  <verify>
- `curl -N http://localhost:3000/sse` returns SSE event stream (Content-Type: text/event-stream)
- SSE stream sends endpoint event with /messages URL
- POST to /messages with valid sessionId returns 200
- POST to /messages with invalid sessionId returns 400
  </verify>
  <done>SSE fallback endpoints (GET /sse, POST /messages) are functional, older MCP clients can connect via SSE transport, sessions are tracked and cleaned up on disconnect</done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for all Phase 1 success criteria</name>
  <files>
    src/__tests__/config.test.ts
    src/__tests__/envelope.test.ts
    src/__tests__/transport.test.ts
  </files>
  <action>
Create tests that prove every Phase 1 success criterion. Use Vitest. Tests exercise real MCP protocol interactions, not just unit logic.

**src/__tests__/config.test.ts** -- Config validation tests (Success Criterion 5):
- Test: `loadConfig()` with COURTLISTENER_API_KEY set returns config object with the key
- Test: `loadConfig()` without COURTLISTENER_API_KEY calls process.exit(1). Mock `process.exit` to prevent actual exit, then assert it was called with 1.
- Test: PORT defaults to 3000 when not set
- Test: PORT coerces string "8080" to number 8080

**src/__tests__/envelope.test.ts** -- Response envelope tests (Success Criterion 4):
- Test: `createToolResponse({ valid: true, metadata: { foo: "bar" }, error: null })` returns object with content array containing one text item
- Test: The text content is valid JSON that parses to `{ valid: true, metadata: { foo: "bar" }, error: null }`
- Test: Error envelope `{ valid: false, metadata: null, error: { code: "TEST", message: "fail" } }` serializes correctly
- Test: Envelope always has exactly three top-level keys: valid, metadata, error

**src/__tests__/transport.test.ts** -- Integration tests (Success Criteria 1, 2, 3):
These tests start a real server on a random port and make HTTP requests.

Setup: In `beforeAll`, set COURTLISTENER_API_KEY env var, call `createApp()`, start listening on port 0 (OS-assigned), capture the assigned port. In `afterAll`, close the server.

Test group: "Streamable HTTP (Success Criterion 1)":
- Test: POST /mcp with initialize request returns 200 with JSON-RPC response containing server capabilities (name "lexcerta", tools capability)
- Test: POST /mcp with echo tool call returns 200 with response containing echo in envelope format
- Test: GET /mcp returns 405
- Test: DELETE /mcp returns 405

Test group: "Input validation (Success Criterion 3)":
- Test: POST /mcp with echo tool call where message is empty string returns error (Zod min(1) validation). Send a tools/call request with `{ name: "echo", arguments: { message: "" } }`. The response should contain an error (either JSON-RPC error or isError flag).
- Test: POST /mcp with echo tool call where message field is missing returns error. Send `{ name: "echo", arguments: {} }`.
- Test: POST /mcp with echo tool call with valid message returns success envelope with valid=true

Test group: "SSE fallback (Success Criterion 2)":
- Test: GET /sse returns 200 with Content-Type text/event-stream
- Test: POST /messages with invalid sessionId returns 400

NOTE on MCP protocol interactions: Each tool call requires a full JSON-RPC sequence. For Streamable HTTP (stateless), each POST is independent -- send initialize first, then in a separate POST send the tool call. The SDK creates a fresh server per request in stateless mode, so you may need to send initialize + tool call in the same request batch OR test the echo tool by sending the full sequence. Check how the SDK handles stateless tool calls -- it may auto-initialize.

If testing tool calls via HTTP is complex (multi-step JSON-RPC), simplify: test initialize returns capabilities (proves transport works), test envelope format separately, test validation by sending malformed tool call params. The key is proving the success criteria, not testing every MCP protocol edge case.
  </action>
  <verify>
- `npm test` runs all tests and passes
- Test count: at least 10 tests across 3 files
- No tests are skipped or marked todo
- Tests cover all 5 Phase 1 success criteria
  </verify>
  <done>All tests pass, covering: (1) Streamable HTTP returns capabilities, (2) SSE fallback connects, (3) invalid input returns validation error, (4) responses use envelope format, (5) missing config prevents startup</done>
</task>

</tasks>

<verification>
1. `npm test` passes all tests
2. GET /sse returns SSE event stream with endpoint event
3. POST /messages with valid session routes correctly
4. POST /mcp with invalid tool input returns validation error
5. All tests map to Phase 1 success criteria
6. `npx tsc --noEmit` still passes after all changes
</verification>

<success_criteria>
- SSE fallback endpoints functional (GET /sse, POST /messages)
- Zod validation rejects invalid tool inputs before handler execution
- Response envelope format consistent across all tool responses
- Integration tests prove all 5 Phase 1 success criteria
- All tests pass with `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/01-mcp-server-foundation/01-02-SUMMARY.md`
</output>
