---
phase: 01-mcp-server-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - biome.json
  - src/index.ts
  - src/server.ts
  - src/transport.ts
  - src/config.ts
  - src/types.ts
  - src/tools/echo.ts
  - src/logger.ts
autonomous: true

must_haves:
  truths:
    - "MCP client can connect to the server via Streamable HTTP POST /mcp and receive a capabilities response"
    - "Server refuses to start if COURTLISTENER_API_KEY environment variable is missing"
    - "All logging goes to stderr, never stdout"
    - "Echo tool call returns a response with valid/metadata/error envelope fields"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with MCP SDK, Zod, TypeScript, Vitest dependencies"
      contains: "@modelcontextprotocol/sdk"
    - path: "tsconfig.json"
      provides: "TypeScript config with Node16 module resolution, strict mode"
      contains: "Node16"
    - path: "src/index.ts"
      provides: "Entry point: loads config, creates server, starts Express listener"
      exports: []
    - path: "src/server.ts"
      provides: "McpServer factory with tool registration"
      exports: ["createServer"]
    - path: "src/transport.ts"
      provides: "Express app with Streamable HTTP POST/GET/DELETE routes on /mcp"
      exports: ["createApp"]
    - path: "src/config.ts"
      provides: "Zod-validated config loader that exits on missing env vars"
      exports: ["loadConfig", "Config", "ConfigSchema"]
    - path: "src/types.ts"
      provides: "Response envelope type and helper"
      exports: ["ToolResponseEnvelope", "createToolResponse"]
    - path: "src/tools/echo.ts"
      provides: "Echo tool handler for testing"
      exports: ["registerEchoTool"]
    - path: "src/logger.ts"
      provides: "Stderr-only logger"
      exports: ["logger"]
  key_links:
    - from: "src/index.ts"
      to: "src/config.ts"
      via: "loadConfig() call at startup before server creation"
      pattern: "loadConfig"
    - from: "src/index.ts"
      to: "src/transport.ts"
      via: "createApp() to get Express app, then app.listen()"
      pattern: "createApp"
    - from: "src/transport.ts"
      to: "src/server.ts"
      via: "POST /mcp handler calls createServer() per request"
      pattern: "createServer"
    - from: "src/server.ts"
      to: "src/tools/echo.ts"
      via: "registerEchoTool(server) called during server creation"
      pattern: "registerEchoTool"
    - from: "src/tools/echo.ts"
      to: "src/types.ts"
      via: "Uses createToolResponse() to format envelope"
      pattern: "createToolResponse"
---

<objective>
Scaffold the LexCerta project and create a working MCP server with Streamable HTTP transport.

Purpose: Establish the project foundation -- package.json, TypeScript config, source structure, and a running MCP server that handles Streamable HTTP connections on POST /mcp with a placeholder echo tool. This is the skeleton that all subsequent phases build on.

Output: A `npm run dev` command that starts a working MCP server accepting Streamable HTTP tool calls.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mcp-server-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project with dependencies and TypeScript config</name>
  <files>
    package.json
    tsconfig.json
    biome.json
    .gitignore
  </files>
  <action>
Initialize the project at the repository root:

1. Run `npm init -y` and update package.json:
   - name: "lexcerta", version: "0.1.0", type: "module"
   - scripts: dev (`tsx src/index.ts`), build (`tsc`), start (`node build/index.js`), test (`vitest`), lint (`biome check src/`), format (`biome format --write src/`)
   - Dependencies: `@modelcontextprotocol/sdk@^1.26` and `zod@^3.25`
   - Dev dependencies: `typescript@^5.7`, `@types/node`, `tsx`, `vitest`, `@biomejs/biome`, `@types/express`

2. Create tsconfig.json with: target ES2022, module Node16, moduleResolution Node16, outDir ./build, rootDir ./src, strict true, esModuleInterop true, skipLibCheck true, forceConsistentCasingInFileNames true. Include src/**/*. Exclude node_modules.

3. Run `npx @biomejs/biome init` to create biome.json, then configure it: enable formatter (indent with tabs, line width 100), enable linter with recommended rules, organize imports on.

4. Create .gitignore with: node_modules/, build/, .env, *.tgz, .DS_Store

5. Run `npm install` to install all dependencies and generate package-lock.json.

IMPORTANT: Do NOT install express separately -- it is bundled inside @modelcontextprotocol/sdk. If importing express fails after install, THEN add express@^5 as a direct dependency (see research open question #1).

6. Create empty src/ directory structure: src/tools/ subdirectory.

7. Verify TypeScript resolves the SDK imports by creating a minimal test: `npx tsx -e "import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'; console.error('SDK OK')"`. If this fails, troubleshoot module resolution.
  </action>
  <verify>
- `npm ls @modelcontextprotocol/sdk` shows ^1.26.x installed
- `npm ls zod` shows ^3.25.x installed
- `npx tsx -e "import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'; console.error('OK')"` prints OK to stderr
- `npx tsc --noEmit` succeeds (once source files exist in Task 2)
  </verify>
  <done>package.json has correct deps/scripts, tsconfig.json has Node16 module resolution with strict mode, biome.json exists, npm install succeeded, SDK import resolves</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server with Streamable HTTP transport and echo tool</name>
  <files>
    src/logger.ts
    src/config.ts
    src/types.ts
    src/tools/echo.ts
    src/server.ts
    src/transport.ts
    src/index.ts
  </files>
  <action>
Create the source files following the research patterns. All files use `import { z } from "zod"` (not zod/v4). All logging uses stderr via the logger module. Never use console.log anywhere.

**src/logger.ts** -- Simple stderr-only logger (MCP-05):
```typescript
export const logger = {
    info: (...args: unknown[]) => console.error("[INFO]", ...args),
    warn: (...args: unknown[]) => console.error("[WARN]", ...args),
    error: (...args: unknown[]) => console.error("[ERROR]", ...args),
    debug: (...args: unknown[]) => console.error("[DEBUG]", ...args),
};
```

**src/config.ts** -- Zod-validated config (DEPLOY-02, DEPLOY-03):
- Define `ConfigSchema` as a Zod object: `COURTLISTENER_API_KEY` (z.string().min(1)), `PORT` (z.coerce.number().default(3000)), `NODE_ENV` (z.enum(["development", "production", "test"]).default("development"))
- Export `loadConfig()`: calls `ConfigSchema.safeParse(process.env)`. On failure, log formatted error via logger.error and call `process.exit(1)`. On success, return parsed data.
- Export the `Config` type and `ConfigSchema`.

**src/types.ts** -- Response envelope (MCP-04):
- Define and export `ToolResponseEnvelope` interface: `{ valid: boolean; metadata: Record<string, unknown> | null; error: { code: string; message: string; details?: unknown } | null }`
- Export `createToolResponse(envelope: ToolResponseEnvelope)` that returns `{ content: [{ type: "text" as const, text: JSON.stringify(envelope) }] }`

**src/tools/echo.ts** -- Placeholder echo tool (MCP-03):
- Import McpServer type, z from zod, createToolResponse from types, logger
- Export `registerEchoTool(server: McpServer)` that calls `server.registerTool("echo", { description: "Echo input back in the standard response envelope (test tool)", inputSchema: { message: z.string().min(1).describe("Message to echo back") } }, handler)`
- Handler returns `createToolResponse({ valid: true, metadata: { echo: message }, error: null })`

**src/server.ts** -- Server factory:
- Import McpServer from SDK, registerEchoTool, logger
- Export `createServer()`: instantiates `new McpServer({ name: "lexcerta", version: "0.1.0" }, { capabilities: { logging: {} } })`, calls `registerEchoTool(server)`, logs tool registration, returns server.

**src/transport.ts** -- Express app with Streamable HTTP routes (MCP-01):
- Import express, StreamableHTTPServerTransport from SDK, createServer, logger
- Export `createApp()` that returns a configured Express app:
  - `app.use(express.json())` -- CRITICAL: Express 5 does not parse JSON by default
  - `POST /mcp`: Create fresh server via `createServer()`, create `new StreamableHTTPServerTransport({ sessionIdGenerator: undefined })` for stateless mode, `await server.connect(transport)`, `await transport.handleRequest(req, res, req.body)`. On res close, call `transport.close()` and `server.close()`. Wrap in try/catch; on error log to stderr and return JSON-RPC internal error if headers not sent.
  - `GET /mcp`: Return 405 with JSON-RPC error `{ code: -32000, message: "Method not allowed." }`
  - `DELETE /mcp`: Same 405 response
  - `GET /health`: Return 200 with `{ status: "ok" }` (useful for testing)

**src/index.ts** -- Entry point:
- Import loadConfig, createApp, logger
- Call `loadConfig()` first (exits if invalid)
- Call `createApp()` to get Express app
- `app.listen(config.PORT, () => logger.info("LexCerta MCP server listening on port", config.PORT))`

After creating all files:
1. Run `npx tsc --noEmit` to verify TypeScript compiles without errors
2. Run `COURTLISTENER_API_KEY=test-key npx tsx src/index.ts &` to start server in background
3. Test Streamable HTTP with curl: `curl -X POST http://localhost:3000/mcp -H "Content-Type: application/json" -H "Accept: application/json" -d '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}},"id":1}'` -- should return capabilities
4. Test 405 on GET: `curl -X GET http://localhost:3000/mcp` -- should return method not allowed
5. Test health endpoint: `curl http://localhost:3000/health` -- should return `{"status":"ok"}`
6. Test that missing config prevents startup: `npx tsx src/index.ts` (without COURTLISTENER_API_KEY) -- should exit with error
7. Kill the background server process
  </action>
  <verify>
- `npx tsc --noEmit` succeeds with zero errors
- `grep -r "console.log" src/` returns no matches (MCP-05 compliance)
- Server starts with `COURTLISTENER_API_KEY=test-key npx tsx src/index.ts`
- `curl -X POST http://localhost:3000/mcp ...initialize...` returns JSON-RPC response with server capabilities
- `curl -X GET http://localhost:3000/mcp` returns 405
- Server without COURTLISTENER_API_KEY exits with non-zero code and stderr error message
  </verify>
  <done>MCP server starts on configured port, accepts Streamable HTTP POST on /mcp with stateless transport, returns capabilities on initialize, returns 405 on GET/DELETE /mcp, has echo tool registered, refuses to start without COURTLISTENER_API_KEY, all logging goes to stderr</done>
</task>

</tasks>

<verification>
1. `npm run dev` with COURTLISTENER_API_KEY=test-key starts server without errors
2. POST /mcp with initialize request returns valid MCP capabilities response
3. POST /mcp with echo tool call returns response in { valid, metadata, error } envelope
4. GET /mcp returns 405 Method Not Allowed
5. Server without COURTLISTENER_API_KEY refuses to start (exits with error to stderr)
6. `grep -r "console.log" src/` returns nothing (no stdout logging)
7. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Project scaffolded with correct dependencies (@modelcontextprotocol/sdk@^1.26, zod@^3.25)
- MCP server accepts Streamable HTTP connections on POST /mcp
- Echo tool registered and callable
- Config validation rejects missing COURTLISTENER_API_KEY at startup
- All logging routes to stderr exclusively
</success_criteria>

<output>
After completion, create `.planning/phases/01-mcp-server-foundation/01-01-SUMMARY.md`
</output>
