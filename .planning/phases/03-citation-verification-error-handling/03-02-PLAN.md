---
phase: 03-citation-verification-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/types.ts
  - src/config.ts
  - src/tools/verify-citation.ts
  - src/server.ts
  - src/tools/__tests__/verify-citation.test.ts
autonomous: true
user_setup:
  - service: courtlistener
    why: "Citation verification requires authenticated CourtListener API access"
    env_vars:
      - name: COURTLISTENER_API_KEY
        source: "https://www.courtlistener.com/sign-in/ -> Profile -> API Keys"

must_haves:
  truths:
    - "verify_west_citation with a real citation returns valid=true with case name, court, date, and reporter metadata"
    - "verify_west_citation with a fabricated citation returns valid=false with HALLUCINATION_DETECTED error code"
    - "verify_west_citation returns status 'rate_limited' when rate limit is exhausted (not false 'not_found')"
    - "verify_west_citation returns status 'error' when CourtListener is down (not false 'not_found')"
    - "verify_west_citation with unparseable input returns PARSE_ERROR before any API call"
  artifacts:
    - path: "src/tools/verify-citation.ts"
      provides: "verify_west_citation MCP tool registration"
      exports: ["registerVerifyCitationTool"]
    - path: "src/types.ts"
      provides: "VerificationStatus type and extended metadata types"
      contains: "VerificationStatus"
    - path: "src/server.ts"
      provides: "Server with verify_west_citation registered"
      contains: "registerVerifyCitationTool"
  key_links:
    - from: "src/tools/verify-citation.ts"
      to: "src/clients/courtlistener.ts"
      via: "CourtListenerClient injected as parameter to registerVerifyCitationTool"
      pattern: "client\\.lookupCitation"
    - from: "src/tools/verify-citation.ts"
      to: "src/parser/index.ts"
      via: "parseCitation called before API lookup"
      pattern: "parseCitation\\("
    - from: "src/server.ts"
      to: "src/tools/verify-citation.ts"
      via: "registerVerifyCitationTool(server, client)"
      pattern: "registerVerifyCitationTool"
    - from: "src/server.ts"
      to: "src/clients/courtlistener.ts"
      via: "Module-level singleton client via getClient(config)"
      pattern: "getClient\\(config\\)"
---

<objective>
Build the `verify_west_citation` MCP tool that ties together the parser (Phase 2) and CourtListener client (Plan 03-01) into a complete verification pipeline. Wire the tool into the MCP server with a singleton client instance.

Purpose: This is the core deliverable of LexCerta -- the tool that determines whether a citation is real or hallucinated. Every response must unambiguously classify the result as one of four states: verified, not_found (hallucination), rate_limited, or error. Misclassification here means either false confidence in a fabricated citation or false alarm on a real one.

Output: Working `verify_west_citation` tool callable over MCP, with the server wired to use a shared CourtListener client singleton.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-citation-verification-error-handling/03-RESEARCH.md
@.planning/phases/03-citation-verification-error-handling/03-01-SUMMARY.md
@src/types.ts
@src/config.ts
@src/server.ts
@src/tools/parse-citation.ts
@src/parser/index.ts
@src/clients/courtlistener.ts
@src/resilience/circuit-breaker.ts
@src/resilience/rate-limiter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verification types and create verify_west_citation tool</name>
  <files>
    src/types.ts
    src/tools/verify-citation.ts
    src/tools/__tests__/verify-citation.test.ts
  </files>
  <action>
**Extend `src/types.ts`:**
Add a `VerificationStatus` type and keep the existing `ToolResponseEnvelope` and `createToolResponse` unchanged:
```typescript
export type VerificationStatus = "verified" | "not_found" | "rate_limited" | "error";
```
No other changes to types.ts -- the existing envelope is flexible enough (metadata is `Record<string, unknown> | null`, error has code + message + details).

**Create `src/tools/verify-citation.ts`:**
- Export `registerVerifyCitationTool(server: McpServer, client: CourtListenerClient): void`.
- Register tool `"verify_west_citation"` with:
  - Description: `"Verify whether a West Reporter citation refers to a real case. Returns case metadata if verified, or a 'Hallucination Detected' error if the citation is fabricated. Distinguishes API failures and rate limits from verification failures."`
  - Input schema: `{ citation: z.string().min(1).describe("West Reporter citation to verify, e.g., '347 U.S. 483'") }`
- Handler logic (three steps):
  1. **Parse locally:** Call `parseCitation(citation)` from `../parser/index.js`. If `!result.ok`, return `createToolResponse({ valid: false, metadata: null, error: { code: "PARSE_ERROR", message: result.error.message } })` -- no API call made.
  2. **Lookup via CourtListener:** Call `client.lookupCitation(parseResult.citation.normalized)`.
  3. **Classify response based on LookupResponse status:**
     - If `lookupResult.status === "rate_limited"`: return `createToolResponse({ valid: false, metadata: { status: "rate_limited" }, error: { code: "RATE_LIMITED", message: "CourtListener API rate limit reached. Try again later.", details: { retryAfterMs: lookupResult.retryAfterMs } } })`.
     - If `lookupResult.status === "error"`: return `createToolResponse({ valid: false, metadata: { status: "error" }, error: { code: "API_ERROR", message: "CourtListener API is currently unavailable. This is NOT a citation verification failure.", details: { message: lookupResult.message } } })`.
     - If `lookupResult.status === "ok"`: examine the matches array:
       - Find the first match where `match.status === 200` and `match.clusters.length > 0`. (Per Pitfall 1 in research: HTTP 200 overall does NOT mean found -- check per-citation `status` field.)
       - If found: return `createToolResponse({ valid: true, metadata: { status: "verified", caseName: cluster.case_name, court: cluster.docket.court, dateFiled: cluster.date_filed, citations: cluster.citations, courtListenerUrl: "https://www.courtlistener.com" + cluster.absolute_url }, error: null })`. If multiple clusters exist, include all (per Pitfall 5: ambiguous citations).
       - If NO match with status 200 and clusters: return `createToolResponse({ valid: false, metadata: { status: "not_found" }, error: { code: "HALLUCINATION_DETECTED", message: 'Citation "${citation}" not found in CourtListener database. This citation may be fabricated.', details: { queriedCitation: citation, normalized: parseResult.citation.normalized } } })`.

**Create `src/tools/__tests__/verify-citation.test.ts`:**
- Mock the CourtListenerClient (create a mock object with `lookupCitation` as `vi.fn()`).
- Mock parseCitation if needed, or use real parser with known inputs.
- Test cases:
  1. **Unparseable input** ("not a citation"): returns PARSE_ERROR, client.lookupCitation never called.
  2. **Rate limited**: client returns `{ status: "rate_limited", retryAfterMs: 720 }` -> tool returns RATE_LIMITED error with status "rate_limited".
  3. **API error**: client returns `{ status: "error", code: "API_ERROR", message: "..." }` -> tool returns API_ERROR with status "error", message includes "NOT a citation verification failure".
  4. **Citation not found (hallucination)**: client returns `{ status: "ok", matches: [{ status: 404, clusters: [], ... }] }` -> tool returns HALLUCINATION_DETECTED with status "not_found".
  5. **Citation verified**: client returns `{ status: "ok", matches: [{ status: 200, clusters: [{ case_name: "Brown v. Board of Education", ... }], ... }] }` -> tool returns valid=true with case metadata and status "verified".
  6. **Empty matches array**: client returns `{ status: "ok", matches: [] }` -> tool returns HALLUCINATION_DETECTED.

Do NOT use a real McpServer in these tests. Test the handler logic directly by extracting it or by calling `registerVerifyCitationTool` with a mock server that captures the handler.
  </action>
  <verify>
```bash
npx vitest run src/tools/__tests__/verify-citation.test.ts
npx tsc --noEmit
```
All 6 test cases pass. TypeScript compiles.
  </verify>
  <done>verify_west_citation tool correctly classifies all four states: verified (with metadata), not_found (HALLUCINATION_DETECTED), rate_limited, and error. Parse errors short-circuit before API call. Per-citation status codes are checked (not HTTP response status).</done>
</task>

<task type="auto">
  <name>Task 2: Wire verify_west_citation into MCP server with singleton client</name>
  <files>
    src/server.ts
    src/config.ts
  </files>
  <action>
**Modify `src/server.ts`:**
- Add imports: `registerVerifyCitationTool` from `./tools/verify-citation.js`, `CourtListenerClient` from `./clients/courtlistener.js`, `courtListenerPolicy` from `./resilience/circuit-breaker.js`, `TokenBucketRateLimiter` from `./resilience/rate-limiter.js`, `Config` type from `./config.js`.
- Create module-level singleton pattern:
  ```typescript
  let sharedClient: CourtListenerClient | null = null;

  function getClient(config: Config): CourtListenerClient {
    if (!sharedClient) {
      const rateLimiter = new TokenBucketRateLimiter();
      sharedClient = new CourtListenerClient(
        config.COURTLISTENER_API_KEY,
        courtListenerPolicy,
        rateLimiter,
      );
    }
    return sharedClient;
  }
  ```
- Change `createServer()` signature to accept `config: Config` parameter: `export function createServer(config: Config): McpServer`.
- Inside `createServer()`: call `const client = getClient(config)`, then `registerVerifyCitationTool(server, client)`.
- Update the debug log to include `verify_west_citation`.
- Per Pitfall 2 in research: The singleton is MODULE-LEVEL, not scoped to the McpServer instance. This is critical because stateless transport creates a new McpServer per request, but the rate limiter and circuit breaker state must persist.
- Also export a `resetClient()` function for testing that sets `sharedClient = null`. This allows tests to inject fresh clients.

**Modify `src/config.ts` (if needed):**
- The existing `COURTLISTENER_API_KEY` is already required in ConfigSchema. No changes needed unless we want to add rate limit configuration. For now, keep it simple -- the 4,500/hr default in TokenBucketRateLimiter is sufficient. No config changes needed.

**Update callers of `createServer()`:**
- Find where `createServer()` is called (likely `src/index.ts` and test files). Update to pass `config`:
  ```typescript
  const config = loadConfig();
  const server = createServer(config);
  ```
- Update test files that call `createServer()` to pass a test config object.
  </action>
  <verify>
```bash
npx vitest run  # All tests pass (existing + new)
npx tsc --noEmit  # No type errors
npm run lint  # No lint errors
```
Verify `createServer` accepts config and registers all three tools:
```bash
grep -n "registerVerifyCitationTool" src/server.ts
grep -n "createServer(config" src/index.ts
```
  </verify>
  <done>Server creates a module-level singleton CourtListenerClient (persists across stateless requests). verify_west_citation is registered alongside echo and parse_citation. createServer accepts Config parameter. All existing tests still pass.</done>
</task>

</tasks>

<verification>
1. `npm test` -- all tests pass (rate-limiter, courtlistener, verify-citation, parser, echo, transport)
2. `npx tsc --noEmit` -- no TypeScript errors
3. `npm run lint` -- no biome lint errors
4. Calling verify_west_citation with unparseable input returns PARSE_ERROR (no API call)
5. Calling verify_west_citation when rate limited returns status "rate_limited" (ERR-03)
6. Calling verify_west_citation when API is down returns status "error" (ERR-01, ERR-02)
7. Calling verify_west_citation with a fabricated citation returns HALLUCINATION_DETECTED (VERIFY-03)
8. Calling verify_west_citation with a real citation returns verified metadata (VERIFY-01, VERIFY-02)
9. Server uses module-level singleton client (Pitfall 2 from research)
</verification>

<success_criteria>
- verify_west_citation is callable as an MCP tool over Streamable HTTP
- Four verification states are unambiguous: verified, not_found, rate_limited, error
- HALLUCINATION_DETECTED error code is used for not-found citations (not a generic error)
- API failures explicitly state "This is NOT a citation verification failure"
- Parser errors short-circuit before any API call
- Singleton client persists across stateless requests (rate limiter + circuit breaker state preserved)
- All phase success criteria from ROADMAP.md are met by the combination of 03-01 + 03-02
</success_criteria>

<output>
After completion, create `.planning/phases/03-citation-verification-error-handling/03-02-SUMMARY.md`
</output>
