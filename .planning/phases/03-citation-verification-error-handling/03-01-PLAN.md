---
phase: 03-citation-verification-error-handling
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/resilience/rate-limiter.ts
  - src/resilience/circuit-breaker.ts
  - src/clients/courtlistener.ts
  - src/resilience/__tests__/rate-limiter.test.ts
  - src/clients/__tests__/courtlistener.test.ts
autonomous: true

must_haves:
  truths:
    - "Token bucket rate limiter tracks requests and blocks when exhausted"
    - "Circuit breaker opens after 5 consecutive 5xx errors and rejects requests immediately"
    - "Rate limit errors (429) do NOT trigger circuit breaker opening"
    - "CourtListener client returns four distinct response statuses: ok, rate_limited, error"
    - "Rate limiter tokens are NOT consumed when circuit breaker is open"
  artifacts:
    - path: "src/resilience/rate-limiter.ts"
      provides: "TokenBucketRateLimiter class"
      exports: ["TokenBucketRateLimiter"]
    - path: "src/resilience/circuit-breaker.ts"
      provides: "Composed cockatiel policy and error types"
      exports: ["courtListenerPolicy", "courtListenerBreaker", "RateLimitError", "ApiError"]
    - path: "src/clients/courtlistener.ts"
      provides: "CourtListenerClient with resilience"
      exports: ["CourtListenerClient", "LookupResponse", "CitationMatch", "ClusterData"]
  key_links:
    - from: "src/clients/courtlistener.ts"
      to: "src/resilience/circuit-breaker.ts"
      via: "courtListenerPolicy injected as IPolicy constructor parameter"
      pattern: "courtListenerPolicy"
    - from: "src/clients/courtlistener.ts"
      to: "src/resilience/rate-limiter.ts"
      via: "TokenBucketRateLimiter injected as constructor parameter"
      pattern: "rateLimiter\\.tryConsume"
---

<objective>
Build the CourtListener API client with resilience infrastructure: token bucket rate limiter, cockatiel circuit breaker + retry + timeout policies, and the HTTP client that composes them.

Purpose: This is the foundation for all CourtListener API interaction. The client must correctly distinguish between rate-limited, server-error, and successful responses -- a requirement for Phase 3's four-state verification model. Getting this wrong means hallucinated citations could be misclassified as API errors or vice versa.

Output: Three modules (`rate-limiter.ts`, `circuit-breaker.ts`, `courtlistener.ts`) with full test coverage, plus cockatiel installed as a dependency.
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-citation-verification-error-handling/03-RESEARCH.md
@src/types.ts
@src/config.ts
@src/server.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install cockatiel and create resilience modules (rate limiter + circuit breaker)</name>
  <files>
    package.json
    src/resilience/rate-limiter.ts
    src/resilience/circuit-breaker.ts
    src/resilience/__tests__/rate-limiter.test.ts
  </files>
  <action>
**Install cockatiel:**
```bash
npm install cockatiel
```

**Create `src/resilience/rate-limiter.ts`:**
- Export `TokenBucketRateLimiter` class with constructor taking `maxTokens` (default 4500 -- 90% of CourtListener's 5,000/hr) and `refillIntervalMs` (default 3,600,000ms = 1 hour).
- `tryConsume(count = 1): boolean` -- refills tokens based on elapsed time, returns true if tokens available and decrements, false otherwise.
- `msUntilNextToken(): number` -- returns milliseconds until next token is available (0 if tokens available now).
- `get remaining(): number` -- returns current token count after refill.
- Private `refill()` method: calculates tokens to add based on `(elapsed / refillIntervalMs) * maxTokens`, caps at maxTokens.
- Follow the exact implementation from `03-RESEARCH.md` Pattern 3.

**Create `src/resilience/circuit-breaker.ts`:**
- Export error types: `RateLimitError` (extends Error, has `retryAfterMs: number` property) and `ApiError` (extends Error, has `statusCode: number` property).
- Import from cockatiel: `circuitBreaker`, `ConsecutiveBreaker`, `handleType`, `retry`, `ExponentialBackoff`, `timeout`, `wrap`.
- Create `serverErrorPolicy` using `handleType(ApiError, err => err.statusCode >= 500)` -- ONLY handles 5xx, NOT 429 or 404.
- Create and export `courtListenerBreaker`: `circuitBreaker(serverErrorPolicy, { halfOpenAfter: 30_000, breaker: new ConsecutiveBreaker(5) })`.
- Create timeout policy: `timeout(5_000)` (5 seconds per request).
- Create retry policy: `retry(serverErrorPolicy, { maxAttempts: 2, backoff: new ExponentialBackoff({ initialDelay: 500, maxDelay: 3_000 }) })`.
- Compose and export: `courtListenerPolicy = wrap(retryPolicy, breaker, timeoutPolicy)` (outer retry -> circuit breaker -> inner timeout).
- Add event listeners on breaker for `onBreak`, `onReset`, `onHalfOpen` that log via `logger` from `../logger.js`.
- Follow the exact implementation from `03-RESEARCH.md` Pattern 2.

**TDD: Create `src/resilience/__tests__/rate-limiter.test.ts`:**
- RED: Write tests FIRST, run to see them fail.
  - `tryConsume()` returns true when tokens available, decrements count.
  - `tryConsume()` returns false when all tokens exhausted.
  - `remaining` reflects current count.
  - Tokens refill proportionally over time (use `vi.useFakeTimers()` to advance time).
  - `msUntilNextToken()` returns 0 when tokens available, positive value when exhausted.
  - Tokens cap at maxTokens (never exceed initial capacity).
- GREEN: Implement rate-limiter.ts to pass all tests.
- REFACTOR: Clean up if needed, run tests again.
  </action>
  <verify>
```bash
npx vitest run src/resilience/__tests__/rate-limiter.test.ts
```
All tests pass. TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
  </verify>
  <done>TokenBucketRateLimiter passes all unit tests. Circuit breaker module exports composed cockatiel policy. `cockatiel` is in package.json dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: CourtListener API client with injected resilience policies</name>
  <files>
    src/clients/courtlistener.ts
    src/clients/__tests__/courtlistener.test.ts
  </files>
  <action>
**Create `src/clients/courtlistener.ts`:**
- Export interfaces: `CitationMatch` (citation, normalized_citations, start_index, end_index, status (number), error_message, clusters), `ClusterData` (absolute_url, case_name, case_name_short, date_filed, docket with court and court_id, citations array), `LookupResponse` (discriminated union: `{ status: "ok"; matches: CitationMatch[] } | { status: "rate_limited"; retryAfterMs: number } | { status: "error"; code: string; message: string }`).
- Export `CourtListenerClient` class:
  - Constructor takes: `apiKey: string`, `policy: IPolicy` (from cockatiel), `rateLimiter: { tryConsume(): boolean; msUntilNextToken(): number }`, optional `baseUrl` (default `https://www.courtlistener.com/api/rest/v4`).
  - `async lookupCitation(normalizedCitation: string): Promise<LookupResponse>`:
    1. Check `rateLimiter.tryConsume()` FIRST -- if false, return `{ status: "rate_limited", retryAfterMs: rateLimiter.msUntilNextToken() }` immediately. This ensures no rate limiter token is wasted and no circuit breaker interaction occurs.
    2. Execute through `this.policy.execute(async ({ signal }) => { ... })`:
       - POST to `${baseUrl}/citation-lookup/` with `Authorization: Token ${apiKey}`, `Content-Type: application/x-www-form-urlencoded`, body `text=${encodeURIComponent(normalizedCitation)}`, passing `signal` for timeout cancellation.
       - If response.status === 429: throw `new RateLimitError(retryAfter ? parseInt(retryAfter) * 1000 : 60_000)`. This is caught by the outer try/catch but does NOT trigger circuit breaker (because serverErrorPolicy only handles ApiError with statusCode >= 500).
       - If response.status >= 500: throw `new ApiError(response.status, ...)`. This IS retried and DOES count toward circuit breaker.
       - Otherwise: parse JSON as `CitationMatch[]` and return `{ status: "ok", matches }`.
    3. Catch block: if `RateLimitError`, return `{ status: "rate_limited", retryAfterMs }`. Otherwise return `{ status: "error", code: "API_ERROR", message }`.
- Follow the exact implementation from `03-RESEARCH.md` complete client example.

**TDD: Create `src/clients/__tests__/courtlistener.test.ts`:**
- RED: Write tests FIRST using `vi.fn()` mocks for fetch (use `vi.stubGlobal('fetch', mockFetch)`), policy, and rate limiter.
  - When rate limiter returns false, client returns `rate_limited` without calling fetch.
  - When API returns 200 with citation matches, client returns `{ status: "ok", matches }`.
  - When API returns 429, client returns `{ status: "rate_limited" }`.
  - When API returns 500, client returns `{ status: "error", code: "API_ERROR" }` (after retries exhausted).
  - Request includes correct Authorization header, Content-Type, and form-encoded body.
  - When circuit breaker is open (policy.execute throws BrokenCircuitError), client returns `{ status: "error" }`.
- GREEN: Implement courtlistener.ts to pass all tests.
- REFACTOR: Clean up, ensure types are exported correctly.

**Mock strategy:** For unit tests, mock `fetch` globally and create a simple pass-through policy `{ execute: (fn) => fn({ signal: new AbortController().signal }) }` to test the client logic in isolation. For the 429 and 500 tests, the mock fetch returns those status codes. For the circuit breaker test, the mock policy throws `BrokenCircuitError`.
  </action>
  <verify>
```bash
npx vitest run src/clients/__tests__/courtlistener.test.ts
npx vitest run  # All project tests pass
npx tsc --noEmit
```
  </verify>
  <done>CourtListenerClient correctly returns `ok`, `rate_limited`, or `error` for all scenarios. Rate limiter is checked before fetch. 429 does not trigger circuit breaker. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npm test` -- all tests pass (rate-limiter + courtlistener + existing parser tests)
2. `npx tsc --noEmit` -- no TypeScript errors
3. `npm run lint` -- no biome lint errors
4. `cockatiel` appears in package.json dependencies
5. Rate limiter tests confirm: tokens deplete, refill over time, block when exhausted
6. Client tests confirm: rate_limited returned before fetch when tokens exhausted, 429 maps to rate_limited (not error), 500 maps to error, 200 maps to ok with parsed matches
</verification>

<success_criteria>
- TokenBucketRateLimiter has 100% branch coverage: consume, exhaust, refill, cap
- CourtListenerClient has tests for all three response paths: ok, rate_limited, error
- 429 from CourtListener is NEVER classified as "not found" or "error" -- always "rate_limited"
- 5xx from CourtListener triggers circuit breaker; 429 does NOT
- All existing tests continue to pass (parser, echo, transport)
</success_criteria>

<output>
After completion, create `.planning/phases/03-citation-verification-error-handling/03-01-SUMMARY.md`
</output>
