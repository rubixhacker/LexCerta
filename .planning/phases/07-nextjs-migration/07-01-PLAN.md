---
phase: 07-nextjs-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - next.config.ts
  - vercel.json
  - .gitignore
  - app/layout.tsx
  - app/page.tsx
  - app/api/mcp/[transport]/route.ts
  - api/server.ts
autonomous: true

must_haves:
  truths:
    - "Project builds successfully with `next build`"
    - "All existing tests pass after config changes"
    - "MCP route handler at app/api/mcp/[transport]/route.ts exports GET, POST, DELETE"
    - "Top-level api/ directory no longer exists"
  artifacts:
    - path: "app/api/mcp/[transport]/route.ts"
      provides: "MCP server route handler"
      exports: ["GET", "POST", "DELETE"]
    - path: "app/layout.tsx"
      provides: "Root layout (required by Next.js)"
      contains: "RootLayout"
    - path: "app/page.tsx"
      provides: "Placeholder home page"
      contains: "LexCerta"
    - path: "next.config.ts"
      provides: "Next.js configuration"
      contains: "nextConfig"
    - path: "tsconfig.json"
      provides: "Updated TypeScript config for Next.js bundler resolution"
      contains: "bundler"
  key_links:
    - from: "app/api/mcp/[transport]/route.ts"
      to: "src/server.ts"
      via: "import registerTools"
      pattern: "import.*registerTools.*from"
    - from: "app/api/mcp/[transport]/route.ts"
      to: "src/config.ts"
      via: "import loadConfig"
      pattern: "import.*loadConfig.*from"
    - from: "package.json"
      to: "next"
      via: "dependency"
      pattern: "\"next\""
---

<objective>
Convert the LexCerta project from a standalone Vercel serverless function to a Next.js App Router application with the MCP endpoint at app/api/mcp/[transport]/route.ts.

Purpose: Phase 7 requires the existing MCP server to run inside Next.js App Router with no functional regressions. This is the foundation for all subsequent v1.1 phases (dashboard, auth, billing).

Output: A Next.js App Router project that builds, passes all tests, and serves the MCP endpoint at /api/mcp/[transport].
</objective>

<execution_context>
@/home/stewart/.claude/get-shit-done/workflows/execute-plan.md
@/home/stewart/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-nextjs-migration/07-RESEARCH.md
@api/server.ts
@tsconfig.json
@package.json
@vercel.json
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Next.js dependencies and update configuration files</name>
  <files>package.json, tsconfig.json, next.config.ts, vercel.json, .gitignore</files>
  <action>
1. Install Next.js and React dependencies:
   ```bash
   npm install next@^15.5.12 react@^19 react-dom@^19
   npm install -D @types/react@^19 @types/react-dom@^19
   ```

2. Update `package.json` scripts (keep existing deps, add new scripts):
   - `"dev": "next dev"` (replaces `tsx src/index.ts`)
   - `"build": "next build"` (replaces `tsc`)
   - `"start": "next start"` (replaces `node build/index.js`)
   - `"dev:mcp": "tsx src/index.ts"` (preserve old dev entry for local MCP debugging)
   - `"test": "vitest"` (unchanged)
   - `"lint": "biome check src/ app/"` (add app/ to lint scope)
   - `"format": "biome format --write src/ app/"` (add app/ to format scope)
   - Keep `"type": "module"` initially -- research says test first, remove only if build errors occur.

3. Replace `tsconfig.json` entirely with Next.js-compatible config:
   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "lib": ["ES2022", "DOM", "DOM.Iterable"],
       "module": "ESNext",
       "moduleResolution": "bundler",
       "jsx": "preserve",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "forceConsistentCasingInFileNames": true,
       "incremental": true,
       "noEmit": true,
       "isolatedModules": true,
       "resolveJsonModule": true,
       "allowJs": true,
       "plugins": [{ "name": "next" }],
       "paths": {
         "@/*": ["./src/*"]
       }
     },
     "include": ["src/**/*", "app/**/*", "next-env.d.ts", ".next/types/**/*.ts"],
     "exclude": ["node_modules"]
   }
   ```
   Key changes: module Node16->ESNext, moduleResolution Node16->bundler, removed rootDir/outDir, added jsx/incremental/noEmit/isolatedModules/paths, expanded include to cover app/.

4. Create `next.config.ts`:
   ```typescript
   import type { NextConfig } from "next";

   const nextConfig: NextConfig = {};

   export default nextConfig;
   ```
   No custom webpack config needed. No `output: 'export'` (we need serverless functions).

5. Simplify `vercel.json` to only set function duration:
   ```json
   {
     "functions": {
       "app/api/mcp/[transport]/route.ts": {
         "maxDuration": 60
       }
     }
   }
   ```
   Remove `"buildCommand": ""` (Next.js needs its build step). Remove catch-all `rewrites` (causes routing collision with Next.js -- see research Pitfall 1).

6. Add Next.js entries to `.gitignore`:
   ```
   .next
   next-env.d.ts
   ```

7. If `"type": "module"` causes `next build` to fail (ESM/CJS interop errors with mcp-handler which is CJS), remove it from package.json. Test iteratively.
  </action>
  <verify>
- `npm install` succeeds without errors (peer dep warnings for mcp-handler SDK mismatch are expected and acceptable)
- `next.config.ts` exists and exports a NextConfig
- `tsconfig.json` has `"moduleResolution": "bundler"` and includes `app/**/*`
- `vercel.json` has no `rewrites` or `buildCommand` keys
- `.gitignore` contains `.next` and `next-env.d.ts`
  </verify>
  <done>All config files updated for Next.js. Dependencies installed. No build attempted yet (route handler not created).</done>
</task>

<task type="auto">
  <name>Task 2: Create App Router structure and MCP route handler</name>
  <files>app/layout.tsx, app/page.tsx, app/api/mcp/[transport]/route.ts</files>
  <action>
1. Create `app/layout.tsx` -- minimal root layout (required by Next.js):
   ```tsx
   export default function RootLayout({ children }: { children: React.ReactNode }) {
     return (
       <html lang="en">
         <body>{children}</body>
       </html>
     );
   }
   ```

2. Create `app/page.tsx` -- placeholder page:
   ```tsx
   export default function Home() {
     return (
       <main>
         <h1>LexCerta</h1>
         <p>Legal citation verification MCP server.</p>
       </main>
     );
   }
   ```

3. Create `app/api/mcp/[transport]/route.ts` -- the MCP handler moved from api/server.ts:
   ```typescript
   import { createMcpHandler } from "mcp-handler";
   import { loadConfig } from "@/config";
   import { registerTools } from "@/server";

   const handler = createMcpHandler(
     (server) => {
       const config = loadConfig();
       registerTools(server, config);
     },
     {
       serverInfo: { name: "lexcerta", version: "0.1.0" },
       capabilities: { logging: {} },
     },
     {
       basePath: "/api/mcp",
       maxDuration: 60,
       verboseLogs: true,
     },
   );

   export { handler as GET, handler as POST, handler as DELETE };
   ```
   Key changes from api/server.ts:
   - `basePath` changes from `"/api"` to `"/api/mcp"` (must match directory path before `[transport]`)
   - Imports use `@/` path alias instead of relative `../src/` paths
   - Import paths drop `.js` extensions (bundler resolution handles this)
   - Everything else is identical

   IMPORTANT: If `@/` path alias does not resolve (build error), fall back to relative imports:
   ```typescript
   import { loadConfig } from "../../../../src/config.js";
   import { registerTools } from "../../../../src/server.js";
   ```
  </action>
  <verify>
- `app/layout.tsx` exists and exports default RootLayout
- `app/page.tsx` exists and exports default Home
- `app/api/mcp/[transport]/route.ts` exists and exports GET, POST, DELETE
- The route handler imports from src/config and src/server (via @/ alias or relative path)
- `basePath` in the handler is `"/api/mcp"` (not `"/api"`)
  </verify>
  <done>App Router skeleton created. MCP route handler moved to Next.js convention. Imports point to existing src/ code.</done>
</task>

<task type="auto">
  <name>Task 3: Remove old api/ directory, verify build and tests pass</name>
  <files>api/server.ts</files>
  <action>
1. Delete the top-level `api/` directory:
   ```bash
   rm -rf api/
   ```
   This removes `api/server.ts` which is now replaced by `app/api/mcp/[transport]/route.ts`.

2. Run `next build` to verify the project compiles:
   ```bash
   npx next build
   ```
   Expected: Build succeeds, producing `.next/` output directory.

   If build fails due to `"type": "module"` in package.json (ESM/CJS interop with mcp-handler):
   - Remove `"type": "module"` from package.json
   - Retry `npx next build`

   If build fails due to `.js` extensions in existing src/ imports under bundler resolution:
   - The `.js` extensions should be tolerated by bundler mode, but if not, check the specific error and fix the affected import.

   If build fails due to `@/` path alias not resolving in route handler:
   - Switch to relative imports in `app/api/mcp/[transport]/route.ts`

3. Run existing tests to verify no regressions:
   ```bash
   npx vitest run
   ```
   Expected: All existing tests pass. If vitest has module resolution issues after tsconfig changes, install and configure `vite-tsconfig-paths`:
   ```bash
   npm install -D vite-tsconfig-paths
   ```
   Create `vitest.config.ts`:
   ```typescript
   import { defineConfig } from "vitest/config";
   import tsconfigPaths from "vite-tsconfig-paths";

   export default defineConfig({
     plugins: [tsconfigPaths()],
     test: {
       globals: true,
     },
   });
   ```

4. Run lint to verify no new issues:
   ```bash
   npx biome check src/ app/
   ```
   Fix any lint issues in the new app/ files.
  </action>
  <verify>
- `api/` directory does not exist: `ls api/ 2>/dev/null` returns nothing
- `npx next build` succeeds with exit code 0
- `npx vitest run` passes all existing tests (248 tests)
- `npx biome check src/ app/` reports no errors
  </verify>
  <done>Old api/ directory removed. Next.js build succeeds. All existing tests pass. Lint clean. The project is a functioning Next.js App Router application.</done>
</task>

</tasks>

<verification>
1. `npx next build` exits 0 -- project compiles as Next.js App Router
2. `npx vitest run` -- all 248 existing tests pass (no regressions)
3. `ls api/` -- top-level api/ directory gone
4. `ls app/api/mcp/\[transport\]/route.ts` -- MCP handler exists at correct path
5. `grep "basePath" app/api/mcp/\[transport\]/route.ts` -- shows "/api/mcp"
6. `grep "bundler" tsconfig.json` -- confirms new module resolution
7. `cat vercel.json` -- no rewrites, no buildCommand
</verification>

<success_criteria>
- Next.js build succeeds (`next build` exit 0)
- All 248 existing tests pass with no modifications to test files
- MCP route handler exports GET, POST, DELETE at app/api/mcp/[transport]/route.ts
- Top-level api/ directory deleted
- vercel.json simplified (no catch-all rewrite, no empty buildCommand)
- tsconfig.json uses bundler module resolution
- .gitignore includes .next and next-env.d.ts
</success_criteria>

<output>
After completion, create `.planning/phases/07-nextjs-migration/07-01-SUMMARY.md`
</output>
